<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Heap Manager &mdash; Dragon  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="BitSet" href="bitset.html" />
    <link rel="prev" title="Managed Memory" href="managed_memory.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> Dragon
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../start/start.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../uguide/uguide.html">Users Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pguide/pguide.html">Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cbook/cbook.html">Solution Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../benchmarks/benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ref/ref.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infrastructure/infrastructure.html">Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../services/services.html">Services</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../components.html">Low-level Components</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="managed_memory.html">Managed Memory</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="managed_memory.html#architecture">Architecture</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">Heap Manager</a></li>
<li class="toctree-l4"><a class="reference internal" href="bitset.html">BitSet</a></li>
<li class="toctree-l4"><a class="reference internal" href="hexdump.html">Hex Dump</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="managed_memory.html#cython-adapters">Cython Adapters</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cy_managedmemory.html"><code class="code docutils literal notranslate"><span class="pre">dragon.managed_memory</span></code> – Managed Memory Cython Adapter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../unordered_map.html">Unordered Map</a></li>
<li class="toctree-l2"><a class="reference internal" href="../broadcast.html">Broadcast Component</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Dragon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../components.html">Low-level Components</a></li>
          <li class="breadcrumb-item"><a href="managed_memory.html">Managed Memory</a></li>
      <li class="breadcrumb-item active">Heap Manager</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/components/managed_memory/heapmanager.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="heap-manager">
<span id="heapmanager"></span><h1>Heap Manager<a class="headerlink" href="#heap-manager" title="Permalink to this heading"></a></h1>
<p><strong>FIXME: This whole section needs to be edited, but the examples still hold up.</strong></p>
<p>The Heap Manager provides low-level services to components within the dragon run-time. The heap manager
dynamically manages memory through a malloc/free interface. The Heap Manager implements a buddy memory
management system. It allocates memory in sizes of powers of two. In doing so, there is no external
fragmentation resulting in unused space between allocations. A user may request any size allocation, but the
heap manager will allocate space equal to or greater than the requested space to bring it to the next power of
two. This results in what is called internal fragmentation within allocations.</p>
<p>In this documentation, the power of two allocations reserved by the heap manager are called blocks. Each block
is composed of one or more segments. A segment is the smallest allocatable size of the heap manager. The
largest allocatable block is composed of all the segments, the entire heap. The overall heap size and the
segment size are user-configurable when the heap is created.</p>
<section id="an-example-of-malloc-and-free">
<h2>An Example of Malloc and Free<a class="headerlink" href="#an-example-of-malloc-and-free" title="Permalink to this heading"></a></h2>
<figure class="align-default" id="id1">
<img alt="components/managed_memory/images/heapallocations.png" src="components/managed_memory/images/heapallocations.png" />
<figcaption>
<p><span class="caption-number">Fig. 44 </span><span class="caption-text"><strong>Figure 1: A Sample Heap with Allocations</strong></span><a class="headerlink" href="#id1" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Consider a 1K heap with a minimum block size of 32 bytes. The smallest allocatable block size is called a
segment. The 1K heap is made up of 32 segments, each of 32 bytes each. Figure 1 shows a heap with allocations
in colors. The first allocation was for 16 bytes, which resulted in a 32 byte allocation (the smallest
possible size for this heap) and was allocated to segment 0. The second allocation was for 500 bytes (actually
512 bytes) which resulted in the allocation of segments 16-31. Then came an allocation of 64 bytes which went
into segments 2 and 3. The allocation of segments 8-15 was for a request of 222 bytes but allocated 256 bytes
since that is the nearest power of 2. Finally, the purple allocation from segments 4-7 resulted from a request
of 112 bytes but again resulted in an allocation of 4 segments and a size of 128 bytes. So the mallocs that
lead to the allocations in figure 1 might be as follows.</p>
<blockquote>
<div><ul class="simple">
<li><p>32 bytes</p></li>
<li><p>512 bytes</p></li>
<li><p>64 bytes</p></li>
<li><p>256 bytes</p></li>
<li><p>128 bytes</p></li>
</ul>
</div></blockquote>
<p>Worst case, the malloc operations are O(log #segments). In other words, there are potentially repeated split
operations that must occur, but the maximum number of splits is based on the maximum and minimum block size
powers. Each split operation is O(1). In this example, the maximum number of splits is 5. In the example above
there were 5 splits required on the first allocation. The second allocation required 0 splits. The third
required two splits. The fourth 0 splits. The fifth and final allocation required 0 splits.</p>
<p>A heap with this maximum block size and minimum block size is initialized as shown in figure 2. Since the heap
manager always manages blocks sizes of powers of 2, a heap is initialized by providing the maximum and minimum
block size powers. In figure 2 the 10 is the 1024 byte maximum block size and 5 is the 32 byte minimum block
size.</p>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-number">Listing 30 </span><span class="caption-text"><strong>Figure 2: Heap Initialization</strong></span><a class="headerlink" href="#id2" title="Permalink to this code"></a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// make a heap of size 1K with 32 byte segments as minimum block size. How much space</span>
<span class="linenos"> 2</span><span class="c1">// is required? This call determines how much space is required for a heap with</span>
<span class="linenos"> 3</span><span class="c1">// maximum block size of 2^10 and minimimum block size of 2^5. In other words,</span>
<span class="linenos"> 4</span><span class="c1">// a 1K to 32 byte block size heap. The 0 is a segment alignment requirement.</span>
<span class="linenos"> 5</span><span class="c1">// The segments will be minimally word aligned even if 0 is provided.</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="n">dragonError_t</span><span class="w"> </span><span class="n">rc</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 8</span><span class="kt">size_t</span><span class="w"> </span><span class="n">heap_size</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 9</span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dragon_heap_size</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">&amp;</span><span class="n">heap_size</span><span class="p">);</span><span class="w"></span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DRAGON_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">12</span><span class="w">    </span><span class="c1">// deal with error.</span>
<span class="linenos">13</span><span class="p">}</span><span class="w"></span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="c1">// get the required space however that might be done.</span>
<span class="linenos">16</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">space</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">dragonDynHeap_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">heap_size</span><span class="p">);</span><span class="w"></span>
<span class="linenos">17</span>
<span class="linenos">18</span><span class="n">dragonDynHeap_t</span><span class="w"> </span><span class="n">heap</span><span class="p">;</span><span class="w"></span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="c1">// Initialize the heap.</span>
<span class="linenos">21</span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dragon_heap_init</span><span class="p">(</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">22</span>
<span class="linenos">23</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DRAGON_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">24</span><span class="w">    </span><span class="c1">// deal with error.</span>
<span class="linenos">25</span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>As blocks are freed, they are joined together into large free blocks if the block and its buddy are free. The
buddy of a block is a block whose address differs from its address by a power of 2 size. For instance, segment
0 in the allocation of figure 1 has segment 1 as its buddy because they are at index 0 and index 1 of the list
of segments. The block starting at segment 2 has its buddy starting at index 0, but since index 0 is currently
split, the buddy of the green block is not available for joining to it once it is freed. To illustrate this
joining of blocks, consider the following sequence of free requests.</p>
<section id="freeing-the-green-block-starting-at-segment-2">
<h3>Freeing the Green Block Starting at Segment 2<a class="headerlink" href="#freeing-the-green-block-starting-at-segment-2" title="Permalink to this heading"></a></h3>
<p>When the green block is freed we examine its buddy which starts at segment 0 and has a segment span of 1
segment. Since the block starting at segment 0 is not free, the green block cannot be joined with its buddy.
The algorithm doesn’t consider anything further, but because segment 0 is in a block of 32 bytes and the green
block is part of a block of 64 bytes, they could not be joined either (at this point anyway).</p>
<figure class="align-default" id="id3">
<img alt="components/managed_memory/images/heapfree1.png" src="components/managed_memory/images/heapfree1.png" />
<figcaption>
<p><span class="caption-number">Fig. 45 </span><span class="caption-text"><strong>Figure 3: After Freeing the Green Block</strong></span><a class="headerlink" href="#id3" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="freeing-the-purple-block-starting-at-segment-4">
<h3>Freeing the Purple Block Starting at Segment 4<a class="headerlink" href="#freeing-the-purple-block-starting-at-segment-4" title="Permalink to this heading"></a></h3>
<p>Freeing the purple allocation starting at segment 4 examines segment 0 as a potential buddy to join with.
However, the segment at 0 is not free and again does not result in any joining of blocks. At this point, there
are three free blocks that are available in the heap. The segment 1 is a 32 byte block. The segments 2 and 3
make up a 64 byte free block. Finally, the segments 4-6 make up a 128 byte free block.</p>
<figure class="align-default" id="id4">
<img alt="components/managed_memory/images/heapfree2.png" src="components/managed_memory/images/heapfree2.png" />
<figcaption>
<p><span class="caption-number">Fig. 46 </span><span class="caption-text"><strong>Figure 4: After Freeing the Purple Block</strong></span><a class="headerlink" href="#id4" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="freeing-the-yellow-block-starting-at-segment-16">
<h3>Freeing the Yellow Block Starting at Segment 16<a class="headerlink" href="#freeing-the-yellow-block-starting-at-segment-16" title="Permalink to this heading"></a></h3>
<p>The 512 byte block starting at segment 16 is freed next and results in once again examining its buddy at
segment 0. Again, segment 0 is not free and no further joining of blocks is possible.</p>
<figure class="align-default" id="id5">
<img alt="components/managed_memory/images/heapfree3.png" src="components/managed_memory/images/heapfree3.png" />
<figcaption>
<p><span class="caption-number">Fig. 47 </span><span class="caption-text"><strong>Figure 5: After Freeing the Yellow Block</strong></span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="freeing-the-orange-block-starting-at-segment-0">
<h3>Freeing the Orange Block Starting at Segment 0<a class="headerlink" href="#freeing-the-orange-block-starting-at-segment-0" title="Permalink to this heading"></a></h3>
<p>Finally, freeing segment 0 results in examining the buddy block. Since segment 0 is in a block of 32 bytes,
the buddy is at segment 1 which is free. These two one segment blocks are joined together forming a 64 byte
free block. But, joining cascades, resulting in now looking at the 64 byte block starting at segment 2. Again,
this block is free so the two blocks are joined, forming a 128 byte block. But again, the 128 byte block
starting at segment 4 is free and is joined with the 128 byte block starting at 0 to form a 256 byte block.
The buddy of this 256 byte block starts at segment 8 which is not free. So the joining of blocks stops at this
point.</p>
<p>At this point there are two free blocks: a 256 byte block starting at segment 0 and a 512 byte block starting
at segment 16.</p>
<figure class="align-default" id="id6">
<img alt="components/managed_memory/images/heapfree4.png" src="components/managed_memory/images/heapfree4.png" />
<figcaption>
<p><span class="caption-number">Fig. 48 </span><span class="caption-text"><strong>Figure 6: After Freeing the Orange Block</strong></span><a class="headerlink" href="#id6" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="freeing-the-maroon-block-starting-at-segment-8">
<h3>Freeing the Maroon Block Starting at Segment 8<a class="headerlink" href="#freeing-the-maroon-block-starting-at-segment-8" title="Permalink to this heading"></a></h3>
<p>Freeing the maroon block starting at segment 8 results in examining the buddy starting at segment 0. Since it
is free and the same size as the block being freed, the blocks are joined together into a block of 512 bytes,
but since its buddy is also free and the same size, the two 512 byte blocks are joined together into one 1K
block.</p>
<figure class="align-default" id="id7">
<img alt="components/managed_memory/images/heapfree5.png" src="components/managed_memory/images/heapfree5.png" />
<figcaption>
<p><span class="caption-number">Fig. 49 </span><span class="caption-text"><strong>Figure 7: After Freeing the Maroon Block</strong></span><a class="headerlink" href="#id7" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="meta-data-and-handles">
<h2>Meta-Data and Handles<a class="headerlink" href="#meta-data-and-handles" title="Permalink to this heading"></a></h2>
<p>The meta-data/data structures required to implement this heap management system include a list of doubly
linked lists, called the free lists, and list of the actual segments making up the minimum size blocks, and
two bit sets, the block set and the free set. There is also a lock associated with the meta-data so the API is
multi-processing compatible.</p>
<figure class="align-default" id="id8">
<img alt="components/managed_memory/images/metadata.png" src="components/managed_memory/images/metadata.png" />
<figcaption>
<p><span class="caption-number">Fig. 50 </span><span class="caption-text"><strong>Figure 8: Meta-Data and Handle Structure</strong></span><a class="headerlink" href="#id8" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>In the meta-data the <em>Segments Ptr</em> is necessary because there might be padding between the <em>Free Lists</em> and
the beginning of the segments, depending on the requested alignment of the segments when the heap is
initialized. The <em>Segments Ptr</em> is initialized to point to where the segments start subject to the alignment
requirement passed to the initialization API call. This is so that later calls to attach to the heap can find
the beginning of the segments without needing to know the alignment requirement and without needing to
re-compute the starting segments address.</p>
<div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-number">Listing 31 </span><span class="caption-text"><strong>Figure 9: C Handle Definition</strong></span><a class="headerlink" href="#id9" title="Permalink to this code"></a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">dragonDynHeapSegment_t</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dragonDynHeap_st</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 4</span><span class="w">    </span><span class="n">pthread_mutex_t</span><span class="o">*</span><span class="w"> </span><span class="n">exclusive_access_ptr</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 5</span><span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">num_segments</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 6</span><span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">segment_size</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 7</span><span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_freelists</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 8</span><span class="w">    </span><span class="kt">size_t</span><span class="o">*</span><span class="w"> </span><span class="n">recovery_needed_ptr</span><span class="p">;</span><span class="w"></span>
<span class="linenos"> 9</span><span class="w">    </span><span class="n">dragonBitSet_t</span><span class="w"> </span><span class="n">block_set</span><span class="p">;</span><span class="w"></span>
<span class="linenos">10</span><span class="w">    </span><span class="n">dragonBitSet_t</span><span class="w"> </span><span class="n">free_set</span><span class="p">;</span><span class="w"></span>
<span class="linenos">11</span><span class="w">    </span><span class="n">dragonDynHeapSegment_t</span><span class="o">**</span><span class="w"> </span><span class="n">free_lists</span><span class="p">;</span><span class="w"></span>
<span class="linenos">12</span><span class="w">    </span><span class="n">dragonDynHeapSegment_t</span><span class="o">*</span><span class="w"> </span><span class="n">segments</span><span class="p">;</span><span class="w"></span>
<span class="linenos">13</span><span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">end_ptr</span><span class="p">;</span><span class="w"></span>
<span class="linenos">14</span><span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">init_handle</span><span class="p">;</span><span class="w"></span>
<span class="linenos">15</span><span class="p">}</span><span class="w"> </span><span class="n">dragonDynHeap_t</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</div>
<p>The handle structure copies fields that can safely be accessed from either the meta-data or the handle. The
pointers within the handle point to shared data structures in the meta-data. The two BitSet handles have
within them pointers that point to the shared BitSet data.</p>
<p>The <em>Block Bit Set</em> has one bit for every segment in the <em>Segments</em> region of the heap. A <em>Block</em> is made up
of one or more segments. The <em>Segment</em> is a logical structure only. The <em>Number of Segments</em> and <em>Segment
Size</em> fields together define the total size of the segment area of the heap.</p>
<p>The corresponding <em>Block Bit</em> is set to one where a block begins within the segments. Initially, the first bit
in the <em>Block Bit Set</em> is set to a 1 and all other bits are zero, indicating that the entire heap is one big
block. When blocks are allocated, its <em>Block Bit</em> remains set. Blocks exist whether allocated or free.</p>
<p>The <em>Free Bit Set</em> is used to identify when a block is free. The <em>Free Bit Set</em> is the same size as the <em>Block
Bit Set</em> and also has one bit per segment in the heap. If the correponding <em>Free Bit Set</em> bit is a one, then
the block starting at that location is free.</p>
<p>The <em>Free Lists</em> is an array of doubly linked lists, one for each possible block size. Block sizes are always
a power of 2 and range from the maximum block size to the minimum block size. In the 1K to 32 byte heap
example, the number of free lists is 5, the difference between 10 and 5 the binary powers of 1K and 32.  Index
0 in the free lists array corresponds to 32 byte blocks. In the 1K heap example index 4 in the free lists
array corresponds to a 1K block, which is the initial state of the free lists array. The initial state of the
1K heap has only one non-null entry in the free lists array at index 4 and pointing to segment 0 of the
segments.</p>
<p>The <em>segments</em> pointer, points at the first segment in the array of segments that make up the blocks of the
heap. This is for internal use only. Likewise, the <em>end_ptr</em> is for internal use only as is the <em>init_handle</em>.</p>
<p>While a description of fields in the handle is provided here, no data in the handle should be accessed
directly. The handle is to be used on calls to the API and should be treated as an opaque type.</p>
</section>
<section id="performance-of-malloc-and-free">
<h2>Performance of Malloc and Free<a class="headerlink" href="#performance-of-malloc-and-free" title="Permalink to this heading"></a></h2>
<p>Each free block of the heap serves as a node in the doubly linked list of free blocks in the heap. When a
block is freed it may be joined together into a larger free block if its buddy is free. If its buddy is not
free, then the block is added to the linked list of free blocks that corresponds to its size. By having one
free list for each possible block size, there is no searching that needs to be done to find a free block of
the right size. Finding a block is a O(1) operation.</p>
<p>The entire structure and current state of the heap can be determined from the segment size, number of
segments, and the block set and free set. The free lists are kept to make it possible to have O(1) malloc
operations. The worst case complexity of the malloc operation is O(log (max block size - min block size)).  In
other words, the worst case is O(n) where n is the number of powers of 2 between the maximum block size and
the minimum block size. This is a result of potential splits of blocks that occur when a malloc is called.
This results in an amortized complexity of O(1) for malloc.</p>
<p>The free operation needs to know the block size of the block being freed which is available by counting the
zeroes to the right of the corresponding bit in the
<em>Block Bit Set</em>. Each zero bit the right of the corresponding bit for the block
in the <em>Block Bit Set</em> indicates that block extends for another segment.  Counting the number of zeroes to the
right is a O(n) operation where <em>n</em> is bounded by the number of segments in the heap. However, the operation
is implemented to consider whole words from the bit set at a time as long as possible, then consider whole
bytes at a time as long as possible, and finally gets to the bit level only when neither words nor bytes can
be read. In other words, the O(n) zeroes to the right operation on bit sets is quite efficiently written,
resulting in very good microsecond elapsed time even in large bit sets.  In the normal case this zeroes to the
right operation is called only once during a free operation. The buddy block is also examined to see if it has
the same block size and is free for posssible joining of the two blocks, but the block size of the buddy is
stored within it as it is in the free list if it is truly free.</p>
<p>In a 4GB heap with minimum block size of 32 bytes, running on a Rome test node, a test was executed with 60
random calls to malloc. Fifty-two of them were able to be satisfied. Eight required blocks that were not
available and had to be rejected. The average malloc execution time was 0.000022 seconds or 22 microseconds.
The average free time for the 52 blocks was 0.000048 seconds or 48 microseconds. The difference in average
malloc vs free time can be attributed to finding the size of the block being freed.</p>
</section>
<section id="recovery-after-corruption">
<h2>Recovery After Corruption<a class="headerlink" href="#recovery-after-corruption" title="Permalink to this heading"></a></h2>
<p>The free and malloc operations rely on the free lists that are constructed by chaining together free blocks
within the heap. However, an errant user process might write past the end of its block, potentially writing
into a free block’s linked list node, thus corrupting the linked list of free blocks. If this happens, the
corruption can be detected in most cases by checking the pointers found in the doubly linked list to make sure
they are truly valid free pointers into the heap. The previous and next pointers in a node in the free list
must contain valid pointers for the beginning of a free block or they may contain null. If the previous and
next pointers are not valid, then there was a corruption that occurred. Likewise, the size of the block is
also stored in the linked list node. If that size is not a valid block size for the heap, then a corruption
occurred. The size of a block in the linked list is recorded as its index into the free lists array. So, if
the block size index is greater than or equal to the number of free lists, it is corrupted.</p>
<p>In the case of corruption within the heap it is possible to recover the correct state of the heap assuming the
block set, free set, and other meta-data at the beginning of the heap have not be corrupted. Since the
meta-data resides before the segments, it is unlikely that an errant user program would overwrite data prior
to its block allocation. Assuming the meta-data is not corrupted, a recover operation can be executed to
rebuild the free lists correctly from this meta-data. This recover operation is left up to the user of the
heap to execute, but any further operations after corruption is detected will result in a
<em>recovery required</em> error code.</p>
</section>
<section id="heap-client-api">
<h2>Heap Client API<a class="headerlink" href="#heap-client-api" title="Permalink to this heading"></a></h2>
<p>The client API is meant for components that want to allocate and manage a heap.  The actual allocation of the
space for the heap is outside the scope of this API. The user of this API must allocate the space and where
and how that allocation is done is irrelevant to this API. The heap can be managed in any memory adderessable
address space. The performance of the API primitives is dependent on the address space being random accessible
memory.</p>
<section id="structures">
<h3>Structures<a class="headerlink" href="#structures" title="Permalink to this heading"></a></h3>
<p>The enumeration of error codes and the handle definition are the two structures that are defined for the heap.</p>
<section id="the-handle">
<h4>The Handle<a class="headerlink" href="#the-handle" title="Permalink to this heading"></a></h4>
<dl class="c type">
<dt class="sig sig-object c" id="c.dragonDynHeapSegment_t">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragonDynHeapSegment_t</span></span></span><a class="headerlink" href="#c.dragonDynHeapSegment_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>A typedef for segments is without type. Segments are memory regions with no inherent type, but it is named
here for use within the handle.</p>
</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.dragonDynHeap_t">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragonDynHeap_t</span></span></span><a class="headerlink" href="#c.dragonDynHeap_t" title="Permalink to this definition"></a><br /></dt>
<dd><p>This is the heap handle specification. It is the definition of the information that is provided by
initializing and/or attaching to a heap structure.</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeap_t.exclusive_access_ptr">
<span class="n"><span class="pre">pthread_mutex_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">exclusive_access_ptr</span></span></span><a class="headerlink" href="#c.dragonDynHeap_t.exclusive_access_ptr" title="Permalink to this definition"></a><br /></dt>
<dd><p>The lock guaranteeing mutually exclusive access to the heap.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeap_t.num_segments">
<span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">num_segments</span></span></span><a class="headerlink" href="#c.dragonDynHeap_t.num_segments" title="Permalink to this definition"></a><br /></dt>
<dd><p>The number of segments in the heap. Blocks are made up of one or more segments allocated in powers of
2.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeap_t.segment_size">
<span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">segment_size</span></span></span><a class="headerlink" href="#c.dragonDynHeap_t.segment_size" title="Permalink to this definition"></a><br /></dt>
<dd><p>The size of the each segment in the heap.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeap_t.num_freelists">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">num_freelists</span></span></span><a class="headerlink" href="#c.dragonDynHeap_t.num_freelists" title="Permalink to this definition"></a><br /></dt>
<dd><p>The number of free lists which is an internal implementation detail of the heap.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeap_t.recovery_needed_ptr">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">recovery_needed_ptr</span></span></span><a class="headerlink" href="#c.dragonDynHeap_t.recovery_needed_ptr" title="Permalink to this definition"></a><br /></dt>
<dd><p>The value referenced by this pointer is non-zero when the heap requires recovery before proceeding
with further allocation and deallocations.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeap_t.block_set">
<span class="n"><span class="pre">dragonBitSet_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">block_set</span></span></span><a class="headerlink" href="#c.dragonDynHeap_t.block_set" title="Permalink to this definition"></a><br /></dt>
<dd><p>A handle to the block set which is an internal implementation detail of the heap.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeap_t.free_set">
<span class="n"><span class="pre">dragonBitSet_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">free_set</span></span></span><a class="headerlink" href="#c.dragonDynHeap_t.free_set" title="Permalink to this definition"></a><br /></dt>
<dd><p>A handle to the free set which is an internal implementation detail of the heap.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeap_t.free_lists">
<a class="reference internal" href="#c.dragonDynHeapSegment_t" title="dragonDynHeapSegment_t"><span class="n"><span class="pre">dragonDynHeapSegment_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">free_lists</span></span></span><a class="headerlink" href="#c.dragonDynHeap_t.free_lists" title="Permalink to this definition"></a><br /></dt>
<dd><p>A pointer to an list of free lists.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeap_t.segments">
<a class="reference internal" href="#c.dragonDynHeapSegment_t" title="dragonDynHeapSegment_t"><span class="n"><span class="pre">dragonDynHeapSegment_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">segments</span></span></span><a class="headerlink" href="#c.dragonDynHeap_t.segments" title="Permalink to this definition"></a><br /></dt>
<dd><p>A pointer to the first segment of the heap.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeap_t.end_ptr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">end_ptr</span></span></span><a class="headerlink" href="#c.dragonDynHeap_t.end_ptr" title="Permalink to this definition"></a><br /></dt>
<dd><p>Points at the last byte of the heap’s segments and is stored here so it doesn’t have to be re-computed
each time it is needed.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeap_t.init_handle">
<span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">init_handle</span></span></span><a class="headerlink" href="#c.dragonDynHeap_t.init_handle" title="Permalink to this definition"></a><br /></dt>
<dd><p>This field is non-zero when this handle was created by the initialization of the heap. This handle was
not created by attaching after initialization of the heap.</p>
</dd></dl>

</dd></dl>

</section>
<section id="statistics">
<h4>Statistics<a class="headerlink" href="#statistics" title="Permalink to this heading"></a></h4>
<dl class="c struct">
<dt class="sig sig-object c" id="c.dragonDynHeapStatsAllocationItem_t">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragonDynHeapStatsAllocationItem_t</span></span></span><a class="headerlink" href="#c.dragonDynHeapStatsAllocationItem_t" title="Permalink to this definition"></a><br /></dt>
<dd><dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeapStatsAllocationItem_t.block_size">
<span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">block_size</span></span></span><a class="headerlink" href="#c.dragonDynHeapStatsAllocationItem_t.block_size" title="Permalink to this definition"></a><br /></dt>
<dd><p>The size of a block in the statistics report.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeapStatsAllocationItem_t.num_blocks">
<span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">num_blocks</span></span></span><a class="headerlink" href="#c.dragonDynHeapStatsAllocationItem_t.num_blocks" title="Permalink to this definition"></a><br /></dt>
<dd><p>The current number of free blocks at that size within the heap.</p>
</dd></dl>

</dd></dl>

<dl class="c struct">
<dt class="sig sig-object c" id="c.dragonDynHeapStats_t">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragonDynHeapStats_t</span></span></span><a class="headerlink" href="#c.dragonDynHeapStats_t" title="Permalink to this definition"></a><br /></dt>
<dd><dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeapStats_t.num_segments">
<span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">num_segments</span></span></span><a class="headerlink" href="#c.dragonDynHeapStats_t.num_segments" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of segments in this heap. A segment is the smallest possible block size for a particular heap
allocation.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeapStats_t.segment_size">
<span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">segment_size</span></span></span><a class="headerlink" href="#c.dragonDynHeapStats_t.segment_size" title="Permalink to this definition"></a><br /></dt>
<dd><p>The size of each segment. In other words, the minimum block size for this heap allocation.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeapStats_t.total_size">
<span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">total_size</span></span></span><a class="headerlink" href="#c.dragonDynHeapStats_t.total_size" title="Permalink to this definition"></a><br /></dt>
<dd><p>Total size of the heap in bytes. It will be num_segments * segment_size.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeapStats_t.total_free_space">
<span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">total_free_space</span></span></span><a class="headerlink" href="#c.dragonDynHeapStats_t.total_free_space" title="Permalink to this definition"></a><br /></dt>
<dd><p>The number of free bytes in the heap.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeapStats_t.utilization_pct">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">utilization_pct</span></span></span><a class="headerlink" href="#c.dragonDynHeapStats_t.utilization_pct" title="Permalink to this definition"></a><br /></dt>
<dd><p>The percentage of utilization of this heap. The value will be between 0 and 100 inclusive. This does
not take into account internal fragmentation in the heap. In other words, the value reported here says
nothing about unused space in an allocation. If you request 16 bytes and 32 bytes is the minimum block
size, the block is counted as used, not 50 percent used.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeapStats_t.num_block_sizes">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">num_block_sizes</span></span></span><a class="headerlink" href="#c.dragonDynHeapStats_t.num_block_sizes" title="Permalink to this definition"></a><br /></dt>
<dd><p>The number of different block sizes that the heap maintains.</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.dragonDynHeapStats_t.free_blocks">
<a class="reference internal" href="#c.dragonDynHeapStatsAllocationItem_t" title="dragonDynHeapStatsAllocationItem_t"><span class="n"><span class="pre">dragonDynHeapStatsAllocationItem_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">free_blocks</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">BLOCK_SIZE_MAX_POWER</span></span><span class="w"> </span><span class="o"><span class="pre">-</span></span><span class="w"> </span><span class="n"><span class="pre">BLOCK_SIZE_MIN_POWER</span></span><span class="w"> </span><span class="o"><span class="pre">+</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#c.dragonDynHeapStats_t.free_blocks" title="Permalink to this definition"></a><br /></dt>
<dd><p>Space for up to 58 block sizes, the maximum number of block sizes possible with this heap manager
available in powers of 2.</p>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="api">
<h3>API<a class="headerlink" href="#api" title="Permalink to this heading"></a></h3>
<p>These are the user-facing API calls for heap management.</p>
<section id="life-cycle">
<h4>Life-Cycle<a class="headerlink" href="#life-cycle" title="Permalink to this heading"></a></h4>
<dl class="c function">
<dt class="sig sig-object c" id="c.dragon_heap_size">
<span class="n"><span class="pre">dragonError_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragon_heap_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">max_block_size_power</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">min_block_size_power</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">alignment</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dragon_heap_size" title="Permalink to this definition"></a><br /></dt>
<dd><p>Find the size required to create a heap of the specified size. The size of the heap is given by the
<em>max_block_size_power</em>, a power of 2. If 10 were passed to this function, then the size of the heap would
be 1024 bytes or 1K. The <em>min_block_size_power</em> is the power of 2 that indicates the smallest possible
block size within the heap. The smallest allowable size is 5 (i.e. 32 bytes).</p>
<p>The <em>alignment</em> is the byte alignment requirement of blocks within the heap. If 0 is passed, the blocks
will be at least 8 byte aligned. Non-zero <em>alignment</em> must be a multiple of 8 bytes. The <em>size</em> is the
address of a variable to hold the computed size required to hold a heap of this size.</p>
<p><strong>Returns</strong></p>
<div class="line-block">
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_SUCCESS</span></code></div>
<div class="line-block">
<div class="line">Success.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_MAX_BLOCK_SIZE_TOO_LARGE</span></code></div>
<div class="line-block">
<div class="line">Max size is 62.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_MIN_BLOCK_SIZE_TOO_SMALL</span></code></div>
<div class="line-block">
<div class="line">Min size is 5.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_BAD_ALIGNMENT_REQUEST</span></code></div>
<div class="line-block">
<div class="line">Must be a multiple of 8 bytes.</div>
</div>
</div>
<p><strong>Example Usage</strong></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// make a heap of size 4GB with 4K blocks as minimum block size. How much space</span>
<span class="c1">// is required?</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">heap_size</span><span class="p">;</span><span class="w"></span>
<span class="n">dragonError_t</span><span class="w"> </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dragon_heap_size</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">4096</span><span class="p">,</span><span class="o">&amp;</span><span class="n">heap_size</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DRAGON_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// handle it</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dragon_heap_init">
<span class="n"><span class="pre">dragonError_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragon_heap_init</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <a class="reference internal" href="#c.dragonDynHeap_t" title="dragonDynHeap_t"><span class="n"><span class="pre">dragonDynHeap_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">max_block_size_power</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">min_segment_block_power</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">alignment</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dragon_heap_init" title="Permalink to this definition"></a><br /></dt>
<dd><p>Initialize the heap and a handle to it. The <em>ptr</em> points at a space big enough to hold the heap. The
<em>heap</em> should be the address of a handle for the heap declared as a <a class="reference internal" href="#c.dragonDynHeap_t" title="dragonDynHeap_t"><code class="xref c c-struct docutils literal notranslate"><span class="pre">dragonDynHeap_t</span></code></a> structure.
All other parameters should be identical to a previous call to the <a class="reference internal" href="#c.dragon_heap_size" title="dragon_heap_size"><code class="xref c c-func docutils literal notranslate"><span class="pre">dragon_heap_size()</span></code></a> function.</p>
<p><strong>NOTE</strong>: The requested alignment will be relative to the address of <em>ptr</em>,
the space provided on this call. For instance, if an alignment of 4K is requested, then the segments
within the heap will start on a 4K boundary relative to <em>ptr</em>. If address 101 was passed to this function
then the heap segments would start at address 4K x <em>i</em> + 101 where <em>i</em> is an integer.</p>
<p><strong>Returns</strong></p>
<div class="line-block">
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_SUCCESS</span></code></div>
<div class="line-block">
<div class="line">Success.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_INVALID_POINTER</span></code></div>
<div class="line-block">
<div class="line">Returned if either <em>ptr</em> or <em>heap</em> are null pointers.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_MAX_BLOCK_SIZE_TOO_LARGE</span></code></div>
<div class="line-block">
<div class="line">Max size is 62.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_MIN_BLOCK_SIZE_TOO_SMALL</span></code></div>
<div class="line-block">
<div class="line">Min size is 5.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_BAD_ALIGNMENT_REQUEST</span></code></div>
<div class="line-block">
<div class="line">Must be a multiple of 8 bytes.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EBUSY</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EINVAL</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EAGAIN</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_ENOMEM</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EPERM</span></code></div>
<div class="line-block">
<div class="line">Possible lock return codes.</div>
</div>
</div>
<p><strong>Example Usage</strong></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// make a heap of size 4GB with 4K blocks as minimum block size. How much space</span>
<span class="c1">// is required?</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">heap_size</span><span class="p">;</span><span class="w"></span>
<span class="n">dragonError_t</span><span class="w"> </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dragon_heap_size</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">4096</span><span class="p">,</span><span class="o">&amp;</span><span class="n">heap_size</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DRAGON_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// handle it</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// get the required space. This is one way, but not part of the API.</span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">space</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">dragonDynHeap_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">heap_size</span><span class="p">);</span><span class="w"></span>

<span class="n">dragonDynHeap_t</span><span class="w"> </span><span class="n">heap</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Initialize the heap.</span>
<span class="n">dragonError_t</span><span class="w"> </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dragon_heap_init</span><span class="p">(</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DRAGON_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// handle it</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dragon_heap_destroy">
<span class="n"><span class="pre">dragonError_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragon_heap_destroy</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.dragonDynHeap_t" title="dragonDynHeap_t"><span class="n"><span class="pre">dragonDynHeap_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dragon_heap_destroy" title="Permalink to this definition"></a><br /></dt>
<dd><p>Perform any operations necessary once the heap is no longer needed. The handle passed in there must be the
same handle that was initialized using the <a class="reference internal" href="#c.dragon_heap_init" title="dragon_heap_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">dragon_heap_init()</span></code></a> call.</p>
<p><strong>Returns</strong></p>
<div class="line-block">
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_SUCCESS</span></code></div>
<div class="line-block">
<div class="line">Success.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EBUSY</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EINVAL</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EAGAIN</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_ENOMEM</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EPERM</span></code></div>
<div class="line-block">
<div class="line">Possible lock return codes</div>
</div>
</div>
<p><strong>Example Usage</strong></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">dragonDynHeap_t</span><span class="w"> </span><span class="n">heap</span><span class="p">;</span><span class="w"></span>
<span class="c1">// initialize and use the heap. Then finally destroy it.</span>
<span class="n">dragon_heap_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dragon_heap_attach">
<span class="n"><span class="pre">dragonError_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragon_heap_attach</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span>, <a class="reference internal" href="#c.dragonDynHeap_t" title="dragonDynHeap_t"><span class="n"><span class="pre">dragonDynHeap_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dragon_heap_attach" title="Permalink to this definition"></a><br /></dt>
<dd><p>Attach to a previously intialized heap. The <em>ptr</em> parameter must point at a space that was previously
initialized, possibly in another thread. The handle will be initialized by this call to share the
previously initialized heap with other initialized handles.</p>
<p><strong>Returns</strong></p>
<div class="line-block">
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_SUCCESS</span></code></div>
<div class="line-block">
<div class="line">Success.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_INVALID_POINTER</span></code></div>
<div class="line-block">
<div class="line">Returned if either <em>ptr</em> or <em>heap</em> are null pointers.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_INVALID_HEAP</span></code></div>
<div class="line-block">
<div class="line">Returned if trying to attach to an invalid heap. Consistency of heap state did not pass meaning the heap was likely not a heap structure.</div>
</div>
</div>
<p><strong>Example Usage</strong></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// make a heap of size 4GB with 4K blocks as minimum block size. How much space</span>
<span class="c1">// is required?</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">heap_size</span><span class="p">;</span><span class="w"></span>
<span class="n">dragonError_t</span><span class="w"> </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dragon_heap_size</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">4096</span><span class="p">,</span><span class="o">&amp;</span><span class="n">heap_size</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DRAGON_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// handle it</span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// get the required space.</span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">space</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">dragonDynHeap_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">heap_size</span><span class="p">);</span><span class="w"></span>

<span class="n">dragonError_t</span><span class="w"> </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dragon_heap_init</span><span class="p">(</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DRAGON_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// handle it</span>
<span class="p">}</span><span class="w"></span>

<span class="n">dragonDynHeap_t</span><span class="w"> </span><span class="n">heap2</span><span class="p">;</span><span class="w"></span>
<span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dragon_heap_attach</span><span class="p">(</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">heap2</span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DRAGON_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// handle it</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dragon_heap_detach">
<span class="n"><span class="pre">dragonError_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragon_heap_detach</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.dragonDynHeap_t" title="dragonDynHeap_t"><span class="n"><span class="pre">dragonDynHeap_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dragon_heap_detach" title="Permalink to this definition"></a><br /></dt>
<dd><p>Detach from an attached heap. The <em>heap</em> structure must have been initialized via a
<a class="reference internal" href="#c.dragon_heap_attach" title="dragon_heap_attach"><code class="xref c c-func docutils literal notranslate"><span class="pre">dragon_heap_attach()</span></code></a> call.</p>
<p><strong>Returns</strong></p>
<div class="line-block">
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_SUCCESS</span></code></div>
<div class="line-block">
<div class="line">Success.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_DETACH_BY_OWNER</span></code></div>
<div class="line-block">
<div class="line">Attempt to detach by a heap structure that was initialized by a call to <a class="reference internal" href="#c.dragon_heap_init" title="dragon_heap_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">dragon_heap_init()</span></code></a>.</div>
</div>
</div>
<p><strong>Example Usage</strong></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">dragonDynHeap_t</span><span class="w"> </span><span class="n">heap2</span><span class="p">;</span><span class="w"> </span><span class="c1">// attach this space to a heap.</span>
<span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dragon_heap_detach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap2</span><span class="p">);</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DRAGON_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// handle it</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="services">
<h4>Services<a class="headerlink" href="#services" title="Permalink to this heading"></a></h4>
<dl class="c function">
<dt class="sig sig-object c" id="c.dragon_heap_malloc">
<span class="n"><span class="pre">dragonError_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragon_heap_malloc</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.dragonDynHeap_t" title="dragonDynHeap_t"><span class="n"><span class="pre">dragonDynHeap_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dragon_heap_malloc" title="Permalink to this definition"></a><br /></dt>
<dd><p>Allocate a block of at least <em>size</em> from the heap. The <em>ptr</em> should be the address of a variable where the
allocated block’s pointer can be store.</p>
<p><strong>Returns</strong></p>
<div class="line-block">
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_SUCCESS</span></code></div>
<div class="line-block">
<div class="line">Success.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_INVALID_POINTER</span></code></div>
<div class="line-block">
<div class="line">Attempted to allocate from heap, but <em>heap</em> pointer was null or the <em>ptr</em> pointer was null.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_RECOVERY_REQUIRED</span></code></div>
<div class="line-block">
<div class="line">The heap’s free lists were corrupted by an over-run in some user’s code. The free lists must be rebuilt before any other operations can be called. Call <a class="reference internal" href="#c.dragon_heap_recover" title="dragon_heap_recover"><code class="xref c c-func docutils literal notranslate"><span class="pre">dragon_heap_recover()</span></code></a> to rebuild the free lists.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_REQUESTED_SIZE_LARGER_THAN_HEAP</span></code></div>
<div class="line-block">
<div class="line">Attempt to allocate a block larger than the total heap size.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_REQUESTED_SIZE_NOT_AVAILABLE</span></code></div>
<div class="line-block">
<div class="line">Attempt to allocate a block that could not be satisfied due to the current state of the heap. There was not enough free memory.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EBUSY</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EINVAL</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EAGAIN</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_ENOMEM</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EPERM</span></code></div>
<div class="line-block">
<div class="line">Possible lock return codes</div>
</div>
</div>
<p><strong>Example Usage</strong></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">dragonDynHeap_t</span><span class="w"> </span><span class="n">heap</span><span class="p">;</span><span class="w"></span>
<span class="n">dragonError_t</span><span class="w"> </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dragon_heap_init</span><span class="p">(</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DRAGON_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// handle it</span>
<span class="p">}</span><span class="w"></span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dragon_heap_malloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DRAGON_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// handle it</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dragon_heap_free">
<span class="n"><span class="pre">dragonError_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragon_heap_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.dragonDynHeap_t" title="dragonDynHeap_t"><span class="n"><span class="pre">dragonDynHeap_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dragon_heap_free" title="Permalink to this definition"></a><br /></dt>
<dd><p>Free a block pointed to by <em>ptr</em> in this heap.</p>
<p><strong>Returns</strong></p>
<div class="line-block">
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_SUCCESS</span></code></div>
<div class="line-block">
<div class="line">Success.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_INVALID_POINTER</span></code></div>
<div class="line-block">
<div class="line">Attempted to free from heap, but <em>heap</em> pointer was null or the <em>ptr</em> pointer was null.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EBUSY</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EINVAL</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EAGAIN</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_ENOMEM</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EPERM</span></code></div>
<div class="line-block">
<div class="line">Possible lock return codes</div>
</div>
</div>
<p><strong>Example Usage</strong></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// free the block pointed to by tmp.</span>
<span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dragon_heap_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">DRAGON_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// handle it</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dragon_heap_recover">
<span class="n"><span class="pre">dragonError_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragon_heap_recover</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.dragonDynHeap_t" title="dragonDynHeap_t"><span class="n"><span class="pre">dragonDynHeap_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dragon_heap_recover" title="Permalink to this definition"></a><br /></dt>
<dd><p>Perform free list recovery on the heap. This only needs to be called if the heap becomes corrupted which
is indicated by getting back the return code <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_RECOVERY_REQUIRED</span></code> on some other
heap operation.</p>
<p><strong>Returns</strong></p>
<div class="line-block">
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_SUCCESS</span></code></div>
<div class="line-block">
<div class="line">Success.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_INVALID_POINTER</span></code></div>
<div class="line-block">
<div class="line">Attempted to recover the heap, but <em>heap</em> pointer was null.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EBUSY</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EINVAL</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EAGAIN</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_ENOMEM</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EPERM</span></code></div>
<div class="line-block">
<div class="line">Possible lock return codes</div>
</div>
</div>
<p><strong>Example Usage</strong></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">dragon_heap_recover</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="status-debug">
<h4>Status/Debug<a class="headerlink" href="#status-debug" title="Permalink to this heading"></a></h4>
<dl class="c function">
<dt class="sig sig-object c" id="c.dragon_heap_get_stats">
<span class="n"><span class="pre">dragonError_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragon_heap_get_stats</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.dragonDynHeap_t" title="dragonDynHeap_t"><span class="n"><span class="pre">dragonDynHeap_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span>, <a class="reference internal" href="#c.dragonDynHeapStats_t" title="dragonDynHeapStats_t"><span class="n"><span class="pre">dragonDynHeapStats_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dragon_heap_get_stats" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get statistics from the current state of the heap. The statistics are as reported in the
<a class="reference internal" href="#c.dragonDynHeapStats_t" title="dragonDynHeapStats_t"><code class="xref c c-enum docutils literal notranslate"><span class="pre">dragonDynHeapStats_t</span></code></a> structure.</p>
<p><strong>Returns</strong></p>
<div class="line-block">
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_SUCCESS</span></code></div>
<div class="line-block">
<div class="line">Success.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_INVALID_POINTER</span></code></div>
<div class="line-block">
<div class="line">Attempted to recover the heap, but <em>heap</em> pointer was null.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EBUSY</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EINVAL</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EAGAIN</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_ENOMEM</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EPERM</span></code></div>
<div class="line-block">
<div class="line">Possible lock return codes</div>
</div>
</div>
<p><strong>Example Usage</strong></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">dragonDynHeapStats_t</span><span class="w"> </span><span class="n">stats</span><span class="p">;</span><span class="w"></span>
<span class="n">dragon_heap_get_stats</span><span class="p">(</span><span class="o">&amp;</span><span class="n">heap</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stats</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dragon_heap_dump">
<span class="n"><span class="pre">dragonError_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragon_heap_dump</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">title</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.dragonDynHeap_t" title="dragonDynHeap_t"><span class="n"><span class="pre">dragonDynHeap_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dragon_heap_dump" title="Permalink to this definition"></a><br /></dt>
<dd><p>Print a dump of the heap structure with the given <em>title</em> to standard output. The output looks similar to
this.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>*****************************************************************************************
* DYNAMIC MEMORY HEAP DUMP
* Title goes here.
*****************************************************************************************
*  Size of Heap: 4294967296 (hex 100000000)
*  Number of Segments: 1048576 (hex 100000)
*  Segment Size: 4096 (hex 1000)
*  Meta-Data Pointer:  00007F5218663010
*  Block Set Pointer:  00007F5218663068
*  Free Set Pointer:   00007F5218683070
*  Free Lists Pointer: 00007F52186A3070
*  Segments Pointer:   00007F52186A4010
*  Recovery Needed: FALSE
*  --------------------------------------------------------------------------------------
*   Block Set
*    Size of bitset is 131072
*    BITS:
*    00007F5218663068 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
*    00007F5218663078 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
*    ...
*    00007F5218683058 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
*  --------------------------------------------------------------------------------------
*   Free Set
*    Size of bitset is 131072
*    BITS:
*    00007F5218683070 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
*    00007F5218683080 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
*    ...
*    00007F52186A3060 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
*  --------------------------------------------------------------------------------------
*   Free Lists:
*       index:   pointer to 1st node:   block size (# segments):        free list length:
*           0   0000000000000000                 1                              0
*           1   0000000000000000                 2                              0
*           2   0000000000000000                 4                              0
*           3   0000000000000000                 8                              0
*           4   0000000000000000                16                              0
*           5   0000000000000000                32                              0
*           6   0000000000000000                64                              0
*           7   0000000000000000               128                              0
*           8   0000000000000000               256                              0
*           9   0000000000000000               512                              0
*          10   0000000000000000              1024                              0
*          11   0000000000000000              2048                              0
*          12   0000000000000000              4096                              0
*          13   0000000000000000              8192                              0
*          14   0000000000000000             16384                              0
*          15   0000000000000000             32768                              0
*          16   0000000000000000             65536                              0
*          17   0000000000000000            131072                              0
*          18   0000000000000000            262144                              0
*          19   0000000000000000            524288                              0
*          20   00007F52186A4010           1048576                              1
*  --------------------------------------------------------------------------------------
*  Free Segment Nodes
*  -----------
*  Index: 0
*  Address: 00007F52186A4010
*  Size: 4294967296
*  Number of Segments: 1048576
*  Next: 0000000000000000
*  Prev: 0000000000000000
*****************************************************************************************
</pre></div>
</div>
<p><strong>Returns</strong></p>
<div class="line-block">
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_SUCCESS</span></code></div>
<div class="line-block">
<div class="line">Success.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_INVALID_POINTER</span></code></div>
<div class="line-block">
<div class="line">Attempted to recover the heap, but <em>heap</em> pointer was null.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EBUSY</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EINVAL</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EAGAIN</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_ENOMEM</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EPERM</span></code></div>
<div class="line-block">
<div class="line">Possible lock return codes</div>
</div>
</div>
<p><strong>Example Usage</strong></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">dragon_heap_dump</span><span class="p">(</span><span class="s">&quot;Title goes here.&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.dragon_heap_dump_to_fd">
<span class="n"><span class="pre">dragonError_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dragon_heap_dump_to_fd</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fd</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">title</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.dragonDynHeap_t" title="dragonDynHeap_t"><span class="n"><span class="pre">dragonDynHeap_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.dragon_heap_dump_to_fd" title="Permalink to this definition"></a><br /></dt>
<dd><p>The same as <a class="reference internal" href="#c.dragon_heap_dump" title="dragon_heap_dump"><code class="xref c c-func docutils literal notranslate"><span class="pre">dragon_heap_dump()</span></code></a> except it writes to a user specified file. The effect of calling
this function with <em>stdout</em> as the file is exactly the same as calling <a class="reference internal" href="#c.dragon_heap_dump" title="dragon_heap_dump"><code class="xref c c-func docutils literal notranslate"><span class="pre">dragon_heap_dump()</span></code></a>.</p>
<p><strong>Returns</strong></p>
<div class="line-block">
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_SUCCESS</span></code></div>
<div class="line-block">
<div class="line">Success.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_INVALID_POINTER</span></code></div>
<div class="line-block">
<div class="line">Attempted to recover the heap, but <em>heap</em> pointer was null.</div>
</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EBUSY</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EINVAL</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EAGAIN</span></code>, <code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_ENOMEM</span></code>,</div>
<div class="line"><code class="xref c c-enumerator docutils literal notranslate"><span class="pre">DRAGON_HEAP_LOCK_EPERM</span></code></div>
<div class="line-block">
<div class="line">Possible lock return codes</div>
</div>
</div>
<p><strong>Example Usage</strong></p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="c1">// You can replace logfile with your own open writable file.</span>
<span class="n">dragon_heap_dump</span><span class="p">(</span><span class="n">logfile</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Title goes here.&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">heap</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="managed_memory.html" class="btn btn-neutral float-left" title="Managed Memory" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="bitset.html" class="btn btn-neutral float-right" title="BitSet" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Hewlett Packard Enterprise.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>