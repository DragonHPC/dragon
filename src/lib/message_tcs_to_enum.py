
def main():
    file = open('../dragon/infrastructure/messages.py', 'r')
    in_enum = False
    enum_file = open('../include/dragon/message_tcs.hpp', "w")
    map_file = open('_message_tcs.hpp', "w")
    enum_file.write('#ifndef message_tcs_hpp\n')
    enum_file.write('#define message_tcs_hpp\n')
    enum_file.write('\n')
    enum_file.write('/* DO NOT EDIT THIS FILE. */\n')
    enum_file.write('/* This file was automatically generated by the messages_tc_to_enum.py */\n')
    enum_file.write('/* program. It is a C/C++ duplicate of the typecodes located in */\n')
    enum_file.write('/* src/dragon/infrastructure/messages.py */\n')
    map_file.write('/* DO NOT EDIT THIS FILE. */\n')
    map_file.write('/* This file was automatically generated by the messages_tc_to_enum.py */\n')
    map_file.write('/* program. This provides a mapping of typecode to typecode name. It is */\n')
    map_file.write('/* meant to be only included in messages.cpp. Lookups on the map can be */\n')
    map_file.write('/* can be done by including messages.hpp and calling dragon_msg_tc_name.*/\n')
    map_file.write('#include <string>\n')

    map_file.write('\n')
    map_file.write('static unordered_map<MessageType, std::string> tcMap\n')
    map_file.write('{\n')
    enum_file.write('\n')
    enum_file.write('enum MessageType {\n')
    line_to_write = ''
    map_line = ''
    next_val = 1

    for line in file:
        if line.startswith('class MessageType'):
            in_enum = True
        elif line.startswith('class'):
            break
        if in_enum:
            lst = line.split()
            if len(lst) >= 3 and lst[1] == '=':
                if len(line_to_write) > 0:
                    enum_file.write(f'{line_to_write},\n')
                    map_file.write(f'{map_line},\n')
                    line_to_write = ''
                    map_line = ''
                tc = lst[0]
                val = lst[2]
                if val=='enum.auto()':
                    val = next_val
                    next_val+=1
                line_to_write = f'    {tc} = {val}'
                map_line = '    {' + f'{tc}, "{tc}"' +'}'

    if len(line_to_write) > 0:
        enum_file.write(f'{line_to_write}\n')
        map_file.write(f'{map_line}\n')

    enum_file.write('};\n')
    enum_file.write('\n')
    enum_file.write('#endif\n')
    map_file.write('};\n')


if __name__ == '__main__':
    main()