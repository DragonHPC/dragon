Specification
=============

.. TODO: This needs merge with the docstrings in the code, so we can remove it here.
.. All of this should be autogenerated

`dragon.globalservices.process` --- Process Services
----------------------------------------------------

Dragon Process Services consist of calls that can start and
register new user processes.  These API calls concerning processes are all
Python thread safe.

..
    Global services has ultimate ownership of a process entry on this
    level.  Higher constructs implemented in terms of global services
    operations may have their own ideas of ownership and graceful
    takedown.  The purpose of this level is to give enough tools
    to implement these things.

..  py:function:: process.create(exe, run_dir, args, env=None, user_name='', options=None, soft=False)

    Spawns a new process somewhere, managed by the shepherd and runtime system.
    If it didn't work, raise an error.  If there is a user specified
    reference name, checks that this is unique, or picks one uniquely
    if the user doesn't supply one.  This level is only concerned with
    getting an OS process of whatever type running - it might not be a
    Python process or something communicating with infrastructure at all.

    The process will have been started by the time this call returns, or there
    will be an error.

    Options concerning how to launch this process are found in the
    globalservices.process_desc.ProcessOptions object.

    If the create call is with the 'soft' option set then the call will return
    successfully with the appropriate descriptor if the process already exists.
    This only makes sense when the user_name option is set.

    .. container:: figboxright

        .. figure:: images/process_create.srms1.png
            :scale: 50%

    :param str exe: program to run
    :param list args: list of strings, arguments to the program
    :param dict env: key: str, value: str -- environment variables to be added/overridden
    :param str user_name: optional name to refer to the process with.
    :param str run_dir: the working directory from which to run the program.
    :param options: a ProcessOptions object, or an initializer for one; None for default options
    :param bool soft: whether this is a soft create

    :return: object describing the process
    :rtype: ProcessDescriptor
    :raises: ProcessError


..  py:function:: process.get_list()

    Returns (p_uid, name) for all the processes currently
    being managed.

    .. container:: figboxright

        .. figure:: images/process_list.srms1.png
            :scale: 50%

    :return: names of all the processes currently dealt with.
    :rtype: list of tuple (int, str/None)
    :raises: ProcessError

..  py:function:: process.query(identifier)

    Allows any process to query status of another process by name.

    If the identifier is a positive integer type then it is assumed to be the
    numerical process identifier.  If it is a string then it is assumed to be the
    unique string identifier for the process.

    .. container:: figboxright

        .. figure:: images/process_query.srms1.png
            :scale: 50%

    :param identifier: integer or string identifying the process
    :return: object describing the process
    :rtype: ProcessInfo
    :raises: ProcessError

.. py:function:: process.kill(identifier, sig=signal.SIGKILL)

    Allows any process to ask for another one to be killed
    with the specified signal from the signal package.

    .. container:: figboxright

        .. figure:: images/process_kill.srms1.png
            :scale: 50%


    :param identifier: integer or string identifying the process
    :param signal: which signal to send the process
    :return: None
    :raises: ProcessError

..  py:function:: process.join(identifier, timeout = None)

    Waits until the identified process has exited, or the timeout expires. The timeout
    is measured on the global server, not locally.

    Returns the process's exit code, or None if there was a timeout.

    It is an error for a process to request to join itself.

    .. container:: figboxright

        .. figure:: images/process_join.srms1.png
            :scale: 50%

    :param identifier: integer or string identifying the process
    :return: Unix exit code of the process, or None if there is a timeout.
    :rtype: integer or None
    :raises: ProcessError

..  py:function:: process.multi_join(identifiers, timeout = None)

    Waits until at least one process from a list of identified processes has exited, or the timeout
    expires. The timeout is measured on the global server, not locally.

    Returns a dictionary with the status of every process (key: p_uid, value: status_info) along with
    either a list of tuples (p_uid, unix_exit_code) for any processes exited, or None if there was a
    timeout and no processes exited.

    It is an error for a process to request to join itself.

    :param identifiers: list of process identifiers indicating p_uid (int) or process name (string)
    :param timeout: Timeout in seconds for max time to wait. None = default, infinite wait
    :return: list of tuples (p_uid, unix_exit_code) for any processes exited, or None if none exited
             and there is a timeout, along with a dictionary with the status of each process
    :raises: ProcessError

..  py:class:: ProcessDescriptor()

    Contains information about a process.  This should be generally considered impossible
    to instantiate directly - instead it is returned by create() or query().

    Right now this is effectively a local snapshot of info services has about the process.


    .. py:method:: p_uid
       :property:

        Numerical process unique identifier.  This is globally unique
        over the lifetime of the entire user application.

    .. py:method:: user_name
        :property:

        string unique identifier for the process

    .. py:method:: is_alive
        :property:

        True if the process is considered alive, False if not

    .. py:method:: retval
        :property:

        None if the process hasn't started or hasn't completed yet. Otherwise
        integer return code.

    .. py::method:: refresh()

        Refreshes the ProcessInfo by querying the server.

        .. container:: figboxright

            .. figure:: images/process_ProcessInfo_refresh.srms1.png
                :scale: 50%

        :return: None

    .. py::method:: location
        :property:
        PLACEHOLDER
        Should return some object explaining where the process is physically located.

..  py:exception:: ProcessError

    Exception class for errors to do with process creation, querying, etc.


`dragon.globalservices.pool` --- Pool Services
----------------------------------------------

Dragon Pool services consist of calls that cause new memory pools
to be created, and provide handles to them allowing the pools to
be used by different processes.


.. py:function:: pool.create(size, user_name=None, pool_options=None, soft=False)

    Creates a new memory pool.  The pool descriptor that is returned will be in a 'detached' state.


.. py:function:: pool.get_list()

    Returns a list of the m_uid of the currently active memory pools.

    TODO: add some way to be more selective about this, once we have a use case.


..  py:function:: pool.query(identifier)

    Returns the pool descriptor for the specified pool.  The identifier can either be a string
    signifying the user name or an integer m_uid.

.. py:function:: pool.destroy(identifier)

    Destroys the specified memory pool.

    TODO: do we need to have any rules about checking to see if there are channels still
    alive within the pool?  We can't do anything about allocations, but it is definitely known
    to GS whether there are channels on this pool.

.. py:class:: PoolDescriptor

    PLACEHOLDER

    This object contains whatever globalservices knows about a particular pool.  It's not thread safe and
    only represents a snapshot in time of whatever information it contains.

    NOTE: we have a decision to make about whether this is a plain old data type or something that has methods
    that are able to call the basic functions above directly.  Since this is only a convenience and starts to run
    into questions about object life cycle, we will keep things simple for the time being.

    .. py:attribute:: m_uid
        The m_uid of the pool

    .. py:attribute:: name
        The name of this pool

    .. py:attribute:: node
        The index of the node in the allocation this pool is on.

    .. py:attribute:: sdesc
        The serialized pool descriptor


`dragon.globalservices.channel` --- Channel Services
----------------------------------------------------

Dragon Channel Services consist of calls that can register
new channels and provide handles to them that allow objects
to be communicated between processes.

..
    TODO

    add batch create and batch destroy interface.


.. py:function:: channel.create(m_uid, user_name=None, channel_options=None, soft=False)

    Creates a new channel.  The channel descriptor that is returned will be in a 'detached' state.

    System transactions:

    .. container:: figboxright

        .. figure:: images/channel_create.srms1.png
            :scale: 50%

    :param int m_uid: The m_uid of the pool that holds the channel.
    :param str user_name: An optional user supplied name for the channel. It must be globally unique.
    :param channel_options: An options descriptor object
    :type channel_options: ChannelOptions object
    :param bool soft: default False - if the channel with the given name already exists, don't create it but instead
                      just return the descriptor
    :return: A ChannelDescriptor object
    :rtype: ChannelDescriptor
    :raises: ChannelError

..  py:function:: channel.list()

    Returns a list of the c_uid for all the active channels currently
    being managed.

    TODO: need some way to be more selective about this.  One obvious extension is
    to list only those channels in a specific memory pool.


    .. container:: figboxright

        .. figure:: images/channel_list.srms1.png
            :scale: 50%


    :return: the c_uid of all channels currently alive
    :rtype: list of int
    :raises: ChannelError


..  py:function:: channel.query(identifier)

    Returns a descriptor for an existing channel if it is there, otherwise raises.
    The identifier can be an integer object in which case it is taken to be an infrastructure
    assigned channel ID, or a string in which case it is assumed to be a unique user assigned name.

    System transactions:

    .. container:: figboxright

        .. figure:: images/channel_query.srms1.png
            :scale: 50%

    :param identifier: a channel identifier - if an integer, the infrastructure assigned one,
                        if a string, the unique identifier
    :return: A ChannelDescriptor object containing the underlying library's serialized descriptor and other
             information about the channel that has been created.
    :rtype: ChannelDescriptor
    :raises: ChannelError

..  py:function:: channel.join(identifier, timeout)

    Returns a descriptor for an existing channel if it is there, otherwise blocks until
    the timeout expires or the channel is created.

    The identifier here must be a string. This is used for lazy construction of channels and to provide
    a way for the end that is not constructing the channel to block until the channel is made.name.

    :param identifier: the name of the channel to join.
    :param timeout: Optional timeout on the operation; throws if it doesn't finish in time.
    :return: A ChannelDescriptor object containing the underlying library's serialized descriptor and other
             information about the channel that has been created.
    :rtype: ChannelDescriptor
    :raises: TimeoutError

..  py:function:: channel.destroy(identifier)

    Destroys the channel in the infrastructure. Depending on the kind of channel, there may be
    an error if something is still attached to it.

    System transactions:

    .. container:: figboxright

        .. figure:: images/channel_destroy.srms1.png
            :scale: 50%

    Note that this call is NOT a method on the ChannelDescriptor object. There are various reasons but
    mainly we don't want to imply that this gets called when the ChannelDescriptor itself gets
    garbage collected.

    :param identifiers: one or more channel identifiers.
    :return: None
    :raises: ChannelError

..  py:exception:: ChannelError

    Exception class for errors to do with channel creation/query/etc.

..  py:class:: ChannelOptions

    Attributes so far:

    local_opts
        A local channel creation options object, exposing relevant options on the local
        library create call

    ref_count
        bool, default False, whether GS should count references on this
        channel and destroy if count reaches zero

        NOTE: these options will be growing and the scheme needs
        thought for organization.

.. py:class:: ChannelDescriptor

    PLACEHOLDER

    Object that has methods for interacting with any particular channel.  The ChannelDescriptor
    has local state and facts about it aren't magically updated from the system - the final decision
    on whether anything is valid is up to the global services.

    ChannelDescriptor methods are not thread safe from the Python runtime's point of view.
    Thread safety needs to be imposed from a higher level.

    NOTE:
    This object probably will just contain what GlobalServices knows about the channel, including
    the serialized descriptor from the C library.  We probably want other objects (like our dragon.Connection) to
    access the serialized descriptor and use it as a member; what was previously here contemplated
    this object having the attach/detach methods and so on, but that seems to be ultimately redundant
    with what the Cython layer is doing.

    NOTE: some of these might be turned into properties we get by calling the library on the sdesc.

    .. py:attribute:: m_uid

        The m_uid of the pool this channel is in.

    .. py:attribute:: c_uid

        The c_uid of this channel.

    .. py:attribute:: name

        The name of this channel

    .. py:attribute:: node

        The index of the node in the allocation this channel is on.

    .. py:attribute:: sdesc

        The serialized channel descriptor